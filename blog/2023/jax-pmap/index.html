<!DOCTYPE html>
<!-- _layouts/distill.html --><html>
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <!-- Metadata, OpenGraph and Schema.org -->
    

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>ZeRO Optimizer Sharding with xmap and pjit | Benjamin  Fattori</title>
    <meta name="author" content="Benjamin  Fattori">
    <meta name="description" content="Based on [*folio](https://github.com/bogoli/-folio) design.
">
    <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website">


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light">

    <!-- Styles -->
    
    <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%8C%86&lt;/text&gt;&lt;/svg&gt;">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="https://fattorib.github.io/blog/2023/jax-pmap/">
    
    <!-- Dark Mode -->
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark">

    <script src="/assets/js/theme.js"></script>
    <script src="/assets/js/dark_mode.js"></script>
    


    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    <!-- Distill js -->
    <script src="/assets/js/distillpub/template.v2.js"></script>
    <script src="/assets/js/distillpub/transforms.v2.js"></script>
    <script src="/assets/js/distillpub/overrides.js"></script>
    
  </head>

  <body>
<d-front-matter>
    <script async type="text/json">{
      "title": "ZeRO Optimizer Sharding with xmap and pjit",
      "description": "",
      "published": "March 31, 2023",
      "authors": [
        {
          "author": "Benjamin Fattori",
          "authorURL": "fattorib.github.io",
          "affiliations": [
            {
              "name": "",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script>
  </d-front-matter>

  

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Benjamin </span>Fattori</a>
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">

              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">about</a>
              </li>
              
              <!-- Blog -->
              <li class="nav-item active">
                <a class="nav-link" href="/blog/">posts<span class="sr-only">(current)</span></a>
              </li>

              <!-- Other pages -->

              <!-- Toogle theme mode -->
              <li class="toggle-container">
                <button id="light-toggle" title="Change theme">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
                </button>
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <!-- Scrolling Progress Bar -->
      <progress id="progress" value="0">
        <div class="progress-container">
          <span class="progress-bar"></span>
        </div>
      </progress>
    </header>


    <!-- Content -->
    <div class="post distill">

      <d-title>
        <h1>ZeRO Optimizer Sharding with xmap and pjit</h1>
        <p></p>
      </d-title>

      <d-byline></d-byline>

      <d-article>
        

        <p><strong>TL;DR</strong> I improve upon my earlier codebase by implementing ZeRO-1 optimizer sharding using a combination of <code class="language-plaintext highlighter-rouge">xmap</code> and <code class="language-plaintext highlighter-rouge">pjit</code>. The resultant method is more performant and scales better across multiple TPU hosts achieving 67% MFU on a TPU v3-32. I use this method to train a 1.3B parameter decoder-only transformer on 200B tokens. The codebase I wrote can be found <a href="https://github.com/fattorib/ZeRO-transformer" rel="external nofollow noopener" target="_blank">here</a>.</p>

<h2 id="background">Background</h2>

<p>For the past 4 months, I have been spending time learning more about jax and the parallelism APIs it offers. The first large project I completed was an implementation of <a href="https://arxiv.org/abs/1910.02054" rel="external nofollow noopener" target="_blank">ZeRO-1</a> optimizer sharding using the <code class="language-plaintext highlighter-rouge">pmap</code> operator. Using this, I was able to train a 1.1B parameter decoder-only transformer on a TPU v3-32, by using 8-way optimizer state sharding on each of the TPU hosts.</p>

<p>While this was successful, using <code class="language-plaintext highlighter-rouge">pmap</code> requires a lot of manual array handling to ensure that everything passed into a pmapped function can be distributed across the local devices. In my code, this resulted in multiple helper functions solely for sharding/unsharding arrays. In retrospect, these functions were more of a performance bottleneck than I had originally expected. In addition, without some complicated, and error-prone, communication code, extending the optimizer sharding across hosts would be very difficult<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>.</p>

<h2 id="zero-optimizer-sharding-overview">ZeRO Optimizer Sharding Overview</h2>

<p>ZeRO, introduced in the paper <a href="https://arxiv.org/abs/1910.02054" rel="external nofollow noopener" target="_blank">ZeRO: Memory Optimizations Toward Training Trillion Parameter Models</a> by Rajbhandari et al. stands for Zero Redundancy Optimizer. The authors of the paper propose a modification to training using data parallelism (splitting input batches across all available devices) that reduces memory usage by splitting the buffers of the model’s optimizer across all the data parallel ranks. With a proper communication implementation, they are able to retain the high throughput of data parallel training while training larger models than were previously possible. The original paper introduces multiple levels of ZeRO:</p>
<ul>
  <li>ZeRO-1 shards the optimizer states</li>
  <li>ZeRO-2 also shards the gradients as well</li>
  <li>ZeRO-DP shards the model parameters themselves across data parallel ranks, which is similar to <a href="https://engineering.fb.com/2021/07/15/open-source/fsdp/" rel="external nofollow noopener" target="_blank">FullyShardedDataParallel</a>
</li>
</ul>

<h2 id="going-forward---pjit-everything">Going forward - pjit everything?</h2>

<p>I recently got access to some more TPU compute and wanted to extend my previous code to address some of the pain points mentioned above. Originally, I had planned to only use pjit to accomplish this. In theory, this is easy to do: we specify the <code class="language-plaintext highlighter-rouge">PartitionSpec</code> for the optimizer pytree, duplicate that for the gradient pytree, ensure the batches are split across the same axis and then we’re good to go!</p>

<p>In practice, however, I found that naively using pjit this way resulted in significant throughput decreases. I suspect that the pjit-compilied function was forcing a gradient all-reduce every accumulation step, instead of once every batch, decreasing the training throughput by roughly a factor of <code class="language-plaintext highlighter-rouge">gradient_accumulation_steps</code>.</p>

<p><em>However, I have been unable to alleviate this issue even after adding in proper sharding annotations with <code class="language-plaintext highlighter-rouge">with_sharding_constraint</code>, so I suspect that I still have a mistake in my code somewhere. I’m currently going over how <a href="https://github.com/salesforce/jaxformer" rel="external nofollow noopener" target="_blank">jaxformer</a> implements their gradient accumulation code and am hopeful following how <a href="https://github.com/salesforce/jaxformer/blob/main/jaxformer/models/decoder/inter/model.py#L214" rel="external nofollow noopener" target="_blank">they do</a> it will work.</em></p>

<h2 id="xmap-to-the-rescue">xmap to the rescue!</h2>

<p>Thankfully, there is a second jax parallelism API that is intended to shard arrays across multiple hosts: <code class="language-plaintext highlighter-rouge">xmap</code>. The main between <code class="language-plaintext highlighter-rouge">xmap</code> and <code class="language-plaintext highlighter-rouge">pjit</code> that we are interested in is that <code class="language-plaintext highlighter-rouge">xmap</code> compiled code still requires the user to specify how and when collective operations (ex: <code class="language-plaintext highlighter-rouge">pmean</code>, <code class="language-plaintext highlighter-rouge">psum</code>, <code class="language-plaintext highlighter-rouge">all_gather</code>) occur, unlike <code class="language-plaintext highlighter-rouge">pjit</code> which will automatically insert these whenever the compiler deems necessary. From this perspective, <code class="language-plaintext highlighter-rouge">xmap</code> can be seen as a generalization of <code class="language-plaintext highlighter-rouge">pmap</code>, which also requires that users specify when they want collective operations to be applied.</p>

<p>One nice upgrade that <code class="language-plaintext highlighter-rouge">xmap</code> has over <code class="language-plaintext highlighter-rouge">pmap</code> is its reliance on named axes. By specifying a list of named axes to xmap, we can control how inputs and outputs to an xmapped function are sharded as well as how and when operations such as <code class="language-plaintext highlighter-rouge">pmean</code> are applied. Most importantly, xmapped functions compose properly with pjitted functions, something I was not able to get working with <code class="language-plaintext highlighter-rouge">pmap</code> and <code class="language-plaintext highlighter-rouge">pjit</code>.</p>

<h2 id="putting-it-all-together-xmap--pjit">Putting it all together: xmap &amp; pjit</h2>

<p>Because xmap and pjit arrays are of the same type, it is possible to pass the output from an xmapped function into a pjitted function. The communication pattern for the gradient accumulation code is straightforward: we iterate over <code class="language-plaintext highlighter-rouge">gradient_accumulation_steps</code> microbatches and have every TPU core compute its own local set of gradients, once that is completed, we use a single <code class="language-plaintext highlighter-rouge">pmean</code> to synchronize gradients across all TPU cores and we’re done!</p>

<p>From here, we can take these output gradients and shard them to match the <code class="language-plaintext highlighter-rouge">PartitionSpec</code> of the optimizer states. Remember from above, we’ve distributed these across all available TPU cores the easiest way to do this is to just use <code class="language-plaintext highlighter-rouge">ParitionSpec('dp', None)</code> or <code class="language-plaintext highlighter-rouge">ParitionSpec('dp')</code> to shard the first axis of all weights across the data parallel axis, in this case denoted by <code class="language-plaintext highlighter-rouge">'dp'</code>. In the end, the resulting code is compact and easy-to-follow:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">in_axes</span> <span class="o">=</span><span class="p">(</span>
    <span class="p">[...],</span> 
    <span class="p">[</span><span class="sh">'</span><span class="s">batch</span><span class="sh">'</span><span class="p">,</span> <span class="p">...],</span> 
    <span class="p">[...],</span> 
    <span class="p">)</span>

<span class="n">out_axes</span> <span class="o">=</span> <span class="p">(</span>
    <span class="p">[...],</span>
    <span class="p">[...]</span>
<span class="p">)</span>
<span class="c1"># compute gradients with standard data-parallel
</span><span class="n">grads</span><span class="p">,</span> <span class="n">metrics</span> <span class="o">=</span> <span class="nf">xmap</span><span class="p">(</span>
    <span class="nf">partial</span><span class="p">(</span><span class="n">train_step</span><span class="p">,</span> <span class="n">model</span> <span class="o">=</span> <span class="n">model</span><span class="p">,</span> <span class="n">accum_steps</span> <span class="o">=</span> <span class="n">GRAD_ACCUM_STEPS</span><span class="p">),</span>
    <span class="n">in_axes</span><span class="o">=</span><span class="n">in_axes</span><span class="p">,</span>
    <span class="n">out_axes</span><span class="o">=</span><span class="n">out_axes</span><span class="p">,</span>
    <span class="n">axis_resources</span><span class="o">=</span><span class="p">{</span><span class="sh">"</span><span class="s">batch</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">dp</span><span class="sh">"</span><span class="p">}</span>
<span class="p">)(</span><span class="n">params</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">dropout_rng</span><span class="p">)</span>   

<span class="n">grads</span> <span class="o">=</span> <span class="nf">pjit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">,</span> <span class="n">in_axis_resources</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out_axis_resources</span><span class="o">=</span><span class="n">grad_param_spec</span><span class="p">)(</span><span class="n">grads</span><span class="p">)</span>
<span class="n">params</span> <span class="o">=</span> <span class="nf">pjit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">,</span> <span class="n">in_axis_resources</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out_axis_resources</span><span class="o">=</span><span class="n">grad_param_spec</span><span class="p">)(</span><span class="n">params</span><span class="p">)</span>

<span class="c1"># each dp process updates their own copy of the optimizer state before updating params and 
# performing an all-gather to sync params
</span><span class="n">new_params</span><span class="p">,</span><span class="n">new_opt_state</span> <span class="o">=</span> <span class="nf">pjit</span><span class="p">(</span>
    <span class="n">functools</span><span class="p">.</span><span class="nf">partial</span><span class="p">(</span><span class="n">update_opt_state</span><span class="p">,</span> <span class="n">optimizer</span> <span class="o">=</span> <span class="n">tx</span><span class="p">,</span> <span class="n">grad_spec</span> <span class="o">=</span> <span class="n">grad_param_spec</span><span class="p">),</span>
    <span class="n">in_axis_resources</span><span class="o">=</span><span class="p">(</span><span class="n">grad_param_spec</span><span class="p">,</span> <span class="n">opt_state_spec</span><span class="p">,</span> <span class="n">grad_param_spec</span><span class="p">),</span>
    <span class="n">out_axis_resources</span><span class="o">=</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="n">opt_state_spec</span><span class="p">),</span>
<span class="p">)(</span><span class="n">grads</span><span class="p">,</span> <span class="n">opt_state</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
</code></pre></div></div>

<p>In comparison to my original code, this is much more simple. Specifying proper in/out axis resources ensures I don’t need to write any pytree reshaping code which I found eats up device HBM and causes slowdowns. The only manual sharding we do is the pjitted identity functions to shard the gradients and paramaters to the correct processes for the optimizer update.</p>

<h2 id="performance-benchmarks">Performance Benchmarks</h2>

<p>On a TPU v3-32, training a 1.3B parameter model with BF16 mixed-precision, a sequence length of 1024 tokens and a global batch size of 512, the code processes one batch every 1.65 seconds. This converts to 2.638 PFLOP/s or 67% Model FLOPs Utilization (MFU). (TPU Max TFLOPs calculated by multiplying <a href="https://cloud.google.com/tpu/docs/system-architecture-tpu-vm#tpu_v3" rel="external nofollow noopener" target="_blank">peak compute per chip</a> by 32.)</p>

<h2 id="training-a-13b-parameter-decoder-only-transformer">Training a 1.3B Parameter Decoder-only Transformer</h2>

<p>To prove out that my implementation works, I trained a 1.3B parameter language model on 200B tokens from <a href="https://pile.eleuther.ai/" rel="external nofollow noopener" target="_blank">The Pile</a>. Naively, this model requires more than ~17 GiB to store the params and optimizer states alone, which is already more than the 16.0 GiB of memory each TPU V3 core has access to.</p>

<p>I selected The Pile as my training dataset as it is a large and diverse corpus of text that is easily available. To save on storage and processing costs, I only trained for multiple epochs on a small subset of the pile, specifically <code class="language-plaintext highlighter-rouge">00.json.zst</code> to <code class="language-plaintext highlighter-rouge">03.jsonl.zst</code> from <a href="https://the-eye.eu/public/AI/pile/train/" rel="external nofollow noopener" target="_blank">here</a>. The total dataset was shuffled prior to being split into these files, so these slices are still a representative sample of the data. The text was tokenized using the Byte-Level <a href="https://huggingface.co/docs/transformers/model_doc/gpt_neox#transformers.GPTNeoXTokenizerFast" rel="external nofollow noopener" target="_blank">GPTNeoX tokenizer</a>. Sequences were tokenized and an end-of-text token was appended to the end of documents. The total dataset consists of approximately 30B tokens. The pile validation file <a href="https://the-eye.eu/public/AI/pile/" rel="external nofollow noopener" target="_blank">here</a> was used for the validation set.</p>

<p>The training code was implemented in <a href="https://github.com/google/flax" rel="external nofollow noopener" target="_blank">Flax</a> with optimizers from <a href="https://github.com/deepmind/optax" rel="external nofollow noopener" target="_blank">Optax</a>. For reproducibility, the following version of all packages used were:</p>
<details open="">
`flax==0.6.3, optax==0.1.3, jax[tpu]==0.4.6`
</details>

<h3 id="model">Model</h3>

<table>
  <thead>
    <tr>
      <th>Hyperparameter</th>
      <th>Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>n_parameters</td>
      <td>1.3B</td>
    </tr>
    <tr>
      <td>n_layers</td>
      <td>24</td>
    </tr>
    <tr>
      <td>d_model</td>
      <td>2048</td>
    </tr>
    <tr>
      <td>d_ff</td>
      <td>8192</td>
    </tr>
    <tr>
      <td>num_head</td>
      <td>16</td>
    </tr>
    <tr>
      <td>d_head</td>
      <td>128</td>
    </tr>
    <tr>
      <td>vocab_size</td>
      <td>50304</td>
    </tr>
    <tr>
      <td>Positional Encoding</td>
      <td>ALiBi</td>
    </tr>
    <tr>
      <td>n_ctx</td>
      <td>1024</td>
    </tr>
  </tbody>
</table>

<h3 id="training">Training</h3>

<p>The model was trained for 200B tokens with a batch size of ~0.5M tokens using the following hyperparameters:</p>

<table>
  <thead>
    <tr>
      <th>Hyperparameter</th>
      <th>Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Batch Size</td>
      <td>0.5M Tokens</td>
    </tr>
    <tr>
      <td>Peak Learning Rate</td>
      <td>2.0e-4</td>
    </tr>
    <tr>
      <td>Warmup Steps</td>
      <td>2000</td>
    </tr>
    <tr>
      <td>Residual Dropout</td>
      <td>0.1</td>
    </tr>
    <tr>
      <td>Attention Dropout</td>
      <td>0.1</td>
    </tr>
    <tr>
      <td>Embedding Dropout</td>
      <td>0.0</td>
    </tr>
    <tr>
      <td>Precision</td>
      <td>bfloat16</td>
    </tr>
    <tr>
      <td>Weight Decay</td>
      <td>0.1</td>
    </tr>
    <tr>
      <td>Optimizer</td>
      <td>AdamW</td>
    </tr>
    <tr>
      <td>Schedule</td>
      <td>Cosine decay to 2.0e-5</td>
    </tr>
  </tbody>
</table>

<h3 id="benchmarks">Benchmarks</h3>

<p>Benchmarks are performed using my fork of <a href="https://github.com/fattorib/lm-evaluation-harness" rel="external nofollow noopener" target="_blank">lm-evaluation-harness</a>:</p>

<table>
  <thead>
    <tr>
      <th>Model</th>
      <th>LAMBADA PPL</th>
      <th>LAMBADA Acc</th>
      <th>Wikitext BPB</th>
      <th>PIQA Acc</th>
      <th>Hellaswag Acc Norm</th>
      <th>Winogrande Acc</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>GPT-1.3B (Mine)</strong></td>
      <td><strong>7.69</strong></td>
      <td><strong>57.15%</strong></td>
      <td><strong>0.8158</strong></td>
      <td><strong>69.48%</strong></td>
      <td><strong>45.2%</strong></td>
      <td><strong>55.09%</strong></td>
    </tr>
    <tr>
      <td>GPT-Neo 1.3B</td>
      <td>7.498</td>
      <td>57.23%</td>
      <td>-</td>
      <td>71.11%</td>
      <td>48.93%</td>
      <td>55.01%</td>
    </tr>
    <tr>
      <td>GPT-3 1.3B</td>
      <td>5.44</td>
      <td>63.6%</td>
      <td>-</td>
      <td>75.1%</td>
      <td>54.7%</td>
      <td>58.7%</td>
    </tr>
  </tbody>
</table>

<p>The final validation loss on The Pile is 2.206, which works out to a bits-per-byte of 0.83560.</p>

<h2 id="acknowledgements">Acknowledgements</h2>

<p>TPU Development and training supported with Cloud TPUs from Google’s TPU Research Cloud (TRC). Thank you to the excellent TRC team for granting me access to upgraded TPU VMs and for the extensions I received while working on this project!</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p>As and aside, its pretty crazy that <a href="https://arxiv.org/abs/2112.11446" rel="external nofollow noopener" target="_blank">Gopher</a> was trained with tensor-parallelism solely using <code class="language-plaintext highlighter-rouge">pmap</code>! <a href="#fnref:1" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
  </ol>
</div>

      </d-article>

      <d-appendix>
        <d-footnote-list></d-footnote-list>
        <d-citation-list></d-citation-list>
      </d-appendix>

      <d-bibliography src="/assets/bibliography/"></d-bibliography>
</div>

    <!-- Footer -->
<footer class="fixed-bottom">
  <div class="container mt-0">
    All content licensed under <a href="https://creativecommons.org/licenses/by/4.0/" rel="external nofollow noopener" target="_blank">CC-BY 4.0</a> 2024 Benjamin  Fattori. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>.
Last updated: December 30, 2024.
  </div>
</footer>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

  
</body>
</html>
